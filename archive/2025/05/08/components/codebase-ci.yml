# .github/workflows/codebase-ci.yml
# GitHub Actions workflow for Continuous Integration of the Application Codebase
# Includes linting, testing, and security scanning.

name: Codebase CI & Security Scan

# Controls when the workflow will run
on:
  # Trigger on pushes to main and develop branches
  push:
    branches: [ main, develop ]
  # Trigger on pull requests targeting main or develop branches
  pull_request:
    branches: [ main, develop ]
  # Allow manual trigger from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # Job to build, lint, test, and scan the codebase
  build-lint-test-scan:
    name: Build, Lint, Test & Scan
    runs-on: ubuntu-latest # Or specify other runners if needed

    strategy:
      # Optional: Define a matrix if you need to test against multiple versions
      # matrix:
      #   node-version: [18.x, 20.x]
      #   python-version: [3.9, 3.11]
      fail-fast: false # Keep running other matrix jobs even if one fails

    steps:
      # Step 1: Check out the repository code
      - name: Checkout Codebase Repo
        uses: actions/checkout@v4

      # Step 2: Set up Environment (e.g., Node.js, Python, Java, Go)
      # Use multiple setup actions if needed for polyglot repos
      - name: Set up Node.js ${{ matrix.node-version || '20' }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version || '20' }}
          cache: 'npm'

      - name: Set up Python ${{ matrix.python-version || '3.11' }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version || '3.11' }}
          cache: 'pip'

      # Step 3: Install Dependencies
      - name: Install NPM Dependencies
        run: npm ci
      - name: Install Python Dependencies
        run: pip install -r requirements.txt

      # Step 4: Run Code Linters & Formatters
      # Fail the build if linting errors are found
      - name: Run ESLint (JavaScript/TypeScript)
        run: npm run lint:js -- --max-warnings=0
      - name: Run Pylint/Flake8 (Python)
        run: |
          pip install pylint flake8
          pylint path/to/python/code || true # Handle exit codes appropriately if needed
          flake8 path/to/python/code
      # Add other linters/formatters as needed (e.g., Checkstyle for Java)

      # Step 5: Run Unit & Integration Tests
      # Ensure tests generate reports (e.g., JUnit XML) for potential upload
      - name: Run Unit Tests (Jest)
        run: npm test -- --coverage --reporters=default --reporters=jest-junit
      - name: Run Integration Tests (PyTest)
        run: |
          pip install pytest pytest-cov pytest-xdist
          pytest --cov=./ --cov-report=xml --junitxml=pytest-report.xml tests/integration/
      # Add other test suites

      # --- Security Scanning Steps ---

      # Step 6: Run Secrets Scan (e.g., GitGuardian Shield or TruffleHog)
      - name: Scan for Secrets (GitGuardian)
        uses: GitGuardian/ggshield-action@v1.20.0
        env:
          GITGUARDIAN_API_KEY: ${{ secrets.COMPANY_GITGUARDIAN_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Step 7: Run Software Composition Analysis (SCA) (e.g., GitHub Dependency Review)
      - name: Dependency Review (Check for Vulnerable Dependencies & Licenses)
        uses: actions/dependency-review-action@v4.0.0
        with:
          fail-on-severity: 'high' # Fail on high or critical vulnerabilities
          # Define allowed/denied licenses based on Component #1 policies
          # allow-licenses: 'MIT, Apache-2.0, BSD-3-Clause'
          # deny-licenses: 'GPL-2.0, AGPL-3.0, CPOL-1.02'

      # Step 8: Run Static Application Security Testing (SAST) (e.g., GitHub CodeQL)
      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ matrix.language || 'python,javascript' }} # Specify languages in your repo
          # Example: Use specific query suites for deeper security focus
          # queries: +security-extended, +security-and-quality
          # Example: Specify a config file for custom queries/settings
          # config-file: ./.github/codeql/codeql-config.yml

      # Step 8.1: Autobuild (Only needed for compiled languages like Java, C#, Go, C++)
      # If using Python/JS/TS etc., CodeQL often doesn't need this explicit step.
      # - name: Autobuild Application (if applicable)
      #   uses: github/codeql-action/autobuild@v3

      # Step 8.2: Perform CodeQL Analysis
      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

      # --- End Security Scanning Steps ---

      # Step 9: (Optional) Build Application Artifacts (if applicable)
      # - name: Build Application
      #   run: npm run build # or mvn package, go build, etc.

      # Step 10: (Optional) Upload Test Reports / Coverage / Build Artifacts
      # - name: Upload Test Reports
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: test-reports-${{ matrix.node-version || '20' }}-${{ matrix.python-version || '3.11' }}
      #     path: |
      #       junit.xml
      #       pytest-report.xml
      #   if: always() # Always upload reports

      # --- Placeholder for Future AI-Generated Code Review Augmentation ---
      # Step 11: (Future) Analyze AI-Generated Code Contribution
      #  - name: Run AI Code Contribution Analysis
      #    if: contains(github.event.pull_request.labels.*.name, 'ai-generated') # Example trigger condition
      #    run: |
      #       echo "Running specific checks on AI-generated code..."
      #       # script-to-analyze-ai-code.sh --checklist=component8.checklist