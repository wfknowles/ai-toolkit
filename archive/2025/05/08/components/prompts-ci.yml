# .github/workflows/prompts-ci.yml
# GitHub Actions workflow for Continuous Integration of the Prompt Library

name: Prompt Library CI

# Controls when the workflow will run
on:
  # Trigger on pushes to main and develop branches
  push:
    branches: [ main, develop ]
  # Trigger on pull requests targeting main or develop branches
  pull_request:
    branches: [ main, develop ]
  # Allow manual trigger from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # Job to lint and test the prompts
  lint-and-test-prompts:
    name: Lint & Test Prompts
    runs-on: ubuntu-latest # Use the latest available Ubuntu runner

    steps:
      # Step 1: Check out the repository code
      - name: Checkout Prompt Library Repo
        uses: actions/checkout@v4

      # Step 2: Set up Node.js environment (assuming linter/tests use Node/JS)
      # Adjust this if using Python/PyTest etc.
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20' # Specify desired Node.js version
          cache: 'npm' # Enable caching for npm dependencies

      # Step 3: Install dependencies (linter, test runner, LLM clients if needed for tests)
      - name: Install Dependencies
        run: npm ci # Use 'ci' for cleaner installs in CI

      # Step 4: Run the Prompt Linter
      # Assumes a script 'npm run lint:prompts' is defined in package.json
      # that executes our custom linter using .promptlintrc.js (Component #3)
      - name: Run Prompt Linter
        run: npm run lint:prompts

      # Step 5: Run the Prompt Evaluation Tests
      # Assumes a script 'npm test' runs the Jest tests (Component #4)
      # These tests might need LLM API keys for integration tests
      - name: Run Prompt Tests
        # Inject secrets safely if tests need to call real LLM APIs
        # Ensure these tests handle mocking appropriately for PRs from forks if secrets aren't available
        env:
          # Example: OPENAI_API_KEY: ${{ secrets.CI_OPENAI_API_KEY }}
          # ANTHROPIC_API_KEY: ${{ secrets.CI_ANTHROPIC_API_KEY }}
          # Note: Secrets are not passed to workflows triggered by pull_request from forks by default.
          # Tests might need a mode to run against mocks/stubs in such cases.
          TEST_LLM_API_KEY: ${{ secrets.CI_TEST_LLM_API_KEY || 'mock_key_for_forks' }}
        run: npm test

      # Step 6: (Optional) Create report artifacts
      # You could upload lint reports or test results
      # - name: Upload Lint Report
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: prompt-lint-report
      #     path: lint-report.txt # Path to your lint report file
      #   if: failure() # Only upload on failure, for example

      # - name: Upload Test Results
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: prompt-test-results
      #     path: test-results.xml # Path to your test results file
      #   if: always() # Always upload results

  # --- Optional Job: Tagging/Release on Merge to Main ---
  # tag-release:
  #   name: Tag Production Prompt Release
  #   # Only run this job if the Lint & Test job succeeded AND the trigger was a push to 'main'
  #   if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.lint-and-test-prompts.result == 'success' }}
  #   needs: lint-and-test-prompts # Depends on the previous job succeeding
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: write # Need write permission to create tags/releases
  #
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Bump version and push tag (Example using a tool)
  #       # This step would typically use a semantic versioning tool or script
  #       # to determine the next version based on commit messages, create a tag,
  #       # and potentially create a GitHub Release.
  #       # Example placeholder:
  #       run: |
  #         echo "Determining next version..."
  #         # version=$(semantic-release --dry-run | grep 'next release version is' | awk '{print $NF}') # Example
  #         version="v$(date +%Y.%m.%d)" # Simple date-based version example
  #         echo "Creating tag ${version}"
  #         git tag $version
  #         git push origin $version
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}